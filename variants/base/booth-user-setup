#!/usr/bin/env bash
set -euo pipefail

# -----------------------------------------------------------------------------
# booth-user-setup
#
# Purpose:
#   Container entry script that aligns the in-container "coder" user/group with
#   the host's UID/GID, ensures passwordless sudo, prepares $HOME and code path,
#   and finally execs the given command as "coder".
#
#   This allows files created in the container to be owned by the host user
#   when a bind mount is used (e.g., -v $PWD:/home/coder/code).
#
# How it works (idempotent):
#   1)  Ensure group "coder" exists (prefer HOST_GID if free).
#   2)  If some other group owns HOST_GID, move it to a free GID (keep its name).
#   3)  Set "coder" group's GID to HOST_GID.
#   4)  Ensure user "coder" exists and has UID=HOST_UID, primary group "coder",
#       and login shell USER_SHELL (moving any conflicting user out of the way).
#   5)  Add passwordless sudo for "coder".
#   6)  Ensure default dotfiles (.bashrc, .zshrc) exist with custom prompt.
#   7)  Ensure default .profile exists.
#   8)  Append CodingBooth startup hooks to shell rc files.
#   9)  Copy project's home folder (.booth/home) for team-shared defaults.
#   10) Copy seed files from /tmp/cb-home-seed/ (host credentials, etc.).
#   11) Run one-time CodingBooth startup hooks in /usr/share/startup.d.
#   12) Run user custom startup script (--startup or .booth/startup.sh).
#   13) cd into $CODE_DIR and exec the given command as "coder".
#
# Environment variables:
#   HOST_UID           Host user id (default: 1000)
#   HOST_GID           Host group id (default: 1000)
#   USER_SHELL         Shell for "coder" (default: /bin/bash)
#
#   USER_NAME          Target username inside container (default: coder)  [const below]
#   HOME_DIR           Home dir for USER_NAME (default: /home/coder)      [const below]
#   CODE_NAME          Folder name inside container (default: code)       [const below]
#   CODE_DIR           Code dir (default: /home/coder/code)               [const below]
#
# Usage:
#   As container entrypoint (Dockerfile):
#     COPY booth-user-setup /usr/local/bin/
#     ENTRYPOINT ["/usr/local/bin/booth-user-setup"]
#     CMD ["bash"]   # or your default command
#
#   With docker run (example):
#     docker run --rm -it \
#       -e HOST_UID=$(id -u) -e HOST_GID=$(id -g) \
#       -v "$PWD":/home/coder/code \
#       your-image
#
# Notes:
#   * This script prefers to minimally mutate the system: it only moves aside
#     conflicting UID/GID holders when necessary.
#   * Designed to be re-run safely (idempotent).
#   * No-op if host UID/GID matches current "coder" UID/GID and ownership is OK.
# -----------------------------------------------------------------------------

# Verbose logging (default: false)
CB_VERBOSE="${CB_VERBOSE:-false}"
log() {
  if [ "$CB_VERBOSE" = "true" ]; then
    printf '[cb-setup] %s\n' "$*"
  fi
}

log "Start booth-user-setup $@ ..."

#== Constants ==
USER_NAME="coder"
HOME_DIR="/home/${USER_NAME}"

CODE_NAME=${CODE_NAME:-code}
CODE_DIR="/home/${USER_NAME}/${CODE_NAME}"

# Allow environment to override config
USER_SHELL="${USER_SHELL:-/bin/bash}"
HOST_UID="${HOST_UID:-1000}"
HOST_GID="${HOST_GID:-1000}"


log "USER_NAME=$USER_NAME HOME_DIR=$HOME_DIR CODE_DIR=$CODE_DIR"
log "HOST_UID=$HOST_UID HOST_GID=$HOST_GID"

# Find a free numeric uid/gid starting from 2000 to relocate conflicts safely
find_free_uid() { local uid=2000; while getent passwd "$uid" >/dev/null 2>&1; do uid=$((uid+1)); done; echo "$uid"; }
find_free_gid() { local gid=2000; while getent group  "$gid" >/dev/null 2>&1; do gid=$((gid+1)); done; echo "$gid"; }

# Wrappers to hide "no changes" noise while preserving behavior/exit codes
UserMod()  { usermod "$@" 2> >(grep -v -F "usermod: no changes" >&2) ; }
GroupMod() { groupmod "$@" 2> >(grep -v -F "groupmod: no changes" >&2) ; }


log "1) Ensure '$USER_NAME' group exists (with any GID for now). Prefer HOST_GID if free ..."
if ! getent group "$USER_NAME" >/dev/null 2>&1; then
  if getent group "$HOST_GID"  >/dev/null 2>&1; then
    groupadd "$USER_NAME"               # temp gid
  else
    groupadd -g "$HOST_GID" "$USER_NAME"
  fi
fi


log "2) If some other group owns HOST_GID, move it to a free gid (keep its name) ..."
owner_of_host_gid="$(getent group "$HOST_GID" | cut -d: -f1 || true)"
if [ -n "$owner_of_host_gid" ] && [ "$owner_of_host_gid" != "$USER_NAME" ]; then
  tmp_gid="$(find_free_gid)"
  GroupMod -g "$tmp_gid" "$owner_of_host_gid"
fi


log "3) Set 'coder' group's gid to HOST_GID (if not already) ..."
current_gid="$(getent group "$USER_NAME" | cut -d: -f3)"
if [ "$current_gid" != "$HOST_GID" ]; then
  GroupMod -g "$HOST_GID" "$USER_NAME"
fi


log "4) Ensuring user '$USER_NAME' exists and matches HOST_UID..."
existing_uid_user="$(getent passwd "$HOST_UID" | cut -d: -f1 || true)"
if id -u "$USER_NAME" >/dev/null 2>&1; then
  current_uid="$(id -u "$USER_NAME")"
  # minimal additions: detect current primary group name and shell
  current_gid_name="$(id -gn "$USER_NAME")"
  current_shell="$(getent passwd "$USER_NAME" | cut -d: -f7 || true)"

  if [ "$current_uid" != "$HOST_UID" ]; then
    # If another user has HOST_UID, move them out of the way
    if [ -n "$existing_uid_user" ] && [ "$existing_uid_user" != "$USER_NAME" ]; then
      temp_uid="$(find_free_uid)"; UserMod -u "$temp_uid" "$existing_uid_user"
    fi
    UserMod -u "$HOST_UID" -g "$USER_NAME" -s "$USER_SHELL" "$USER_NAME"
  else
    # Only call usermod if group or shell actually differ (avoid "no changes" noise)
    if [ "$current_gid_name" != "$USER_NAME" ] || [ "$current_shell" != "$USER_SHELL" ]; then
      UserMod -g "$USER_NAME" -s "$USER_SHELL" "$USER_NAME"
    fi
  fi
else
  # 'coder' doesn't exist yet; if HOST_UID is already taken, move that user aside
  if [ -n "$existing_uid_user" ] && [ "$existing_uid_user" != "$USER_NAME" ]; then
    temp_uid="$(find_free_uid)"; UserMod -u "$temp_uid" "$existing_uid_user"
  fi
  # Create coder. Reuse existing HOME_DIR if present; otherwise create it (-m).
  if [ -d "$HOME_DIR" ]; then
    useradd    -u "$HOST_UID" -g "$USER_NAME" -s "$USER_SHELL" "$USER_NAME"
  else
    useradd -m -u "$HOST_UID" -g "$USER_NAME" -s "$USER_SHELL" "$USER_NAME"
  fi
fi


log "5) Change the owner after the UID/GID adjustment."
chown -R "$USER_NAME:$USER_NAME" /home/"$USER_NAME" 2>/dev/null || true


log "6) Configuring passwordless sudo for '$USER_NAME'..."
echo "${USER_NAME} ALL=(ALL) NOPASSWD:ALL" >/etc/sudoers.d/${USER_NAME}
chmod 0440 /etc/sudoers.d/${USER_NAME}

# Set up environment for coder and switch to code
export HOME="$HOME_DIR"
export PATH="$HOME/.local/bin:$PATH"
cd "$CODE_DIR" 2>/dev/null || true


# Populate skeleton dotfiles if missing (so non-login shells get env/aliases)
log "7) Ensuring default dotfiles exist in $HOME_DIR..."
if [ ! -f "$HOME_DIR/.bashrc" ]; then
  if [ -f /etc/skel/.bashrc ]; then
    cp /etc/skel/.bashrc "$HOME_DIR/.bashrc"
  fi
  touch "$HOME_DIR/.bashrc"
  echo 'export PS1="\[\e[1;32m\]${CB_CONTAINER_NAME}\[\e[0m\]:\[\e[1;34m\]\w\[\e[0m\]\$ "' >> "$HOME_DIR/.bashrc"
  # the below will include username but we know that it always "coder" so let use the above first to see if that is ok.
  # echo 'export PS1="\[\e[1;32m\]\u\[\e[0m\]@\[\e[1;33m\]${CB_CONTAINER_NAME}\[\e[0m\]:\[\e[1;34m\]\w\[\e[0m\]\$ "' >> "$HOME_DIR/.bashrc"
fi
if [ ! -f "$HOME_DIR/.zshrc" ]; then
  [ -f /etc/skel/.zshrc ] && cp /etc/skel/.zshrc "$HOME_DIR/.zshrc"
  {
    printf '\n# ---- custom prompt (added at build) ----\n'
    printf 'setopt PROMPT_SUBST\n'  # allow ${...} in PROMPT
    printf 'PROMPT="%%B%%F{green}${CB_CONTAINER_NAME}%%b%%f:%%B%%F{blue}%%~%%b%%f> "\n'
    # the below will include username but we know that it always "coder" so let use the above first to see if that is ok.
    # printf 'PROMPT="%%B%%F{green}%%n%%b%%f@%%B%%F{yellow}${CB_CONTAINER_NAME}%%b%%f:%%B%%F{blue}%%~%%b%%f> "\n'
    printf '# ---- end custom prompt ----\n'
  } >> "$HOME_DIR/.zshrc"
  chown "$USER_NAME:$USER_NAME" "$HOME_DIR/.zshrc"
fi


log "8) Ensuring default profile exist in $HOME_DIR..."
if [ ! -f "$HOME_DIR/.profile" ]; then
  if [ -f /etc/skel/.profile ]; then
    cp /etc/skel/.profile "$HOME_DIR/.profile"
  fi
fi

if [ -f "$HOME_DIR/.bashrc" ]; then
  cat >>"$HOME_DIR/.bashrc" <<'RC'

# ---- CodingBooth startup hooks ----
for f in /etc/profile.d/*-cb-*.sh; do
  [ -r "$f" ] && source "$f"
done
RC
fi

if [ -f "$HOME_DIR/.zshrc" ]; then
  cat >>"$HOME_DIR/.zshrc" <<'RC'

# ---- CodingBooth startup hooks ----
for f in /etc/profile.d/*-cb-*.sh; do
  [ -r "$f" ] && source "$f"
done
RC
fi


log "9) Ensuring default profile exist in $HOME_DIR..."
if [ ! -f "$HOME_DIR/.profile" ]; then
  cat >>"$HOME_DIR/.profile" <<'RC'
# Minimal profile for login shells
[ -f /etc/profile ] && . /etc/profile
RC
fi


log "10) Setting permissions for dotfiles..."
chown "$HOST_UID:$HOST_GID" "$HOME_DIR/.bashrc" "$HOME_DIR/.profile" "$HOME_DIR/.zshrc" 2>/dev/null || true


log "11) Copying project's home folder (team-shared defaults)..."
# This allows teams to share common dotfiles, configs, or tool settings via version control.
# Files are copied without overwriting existing ones (cp -rn).
# Prefer new location (.booth/home)
CB_HOME_DIR=""
if [ -d "$CODE_DIR/.booth/home" ]; then
  CB_HOME_DIR="$CODE_DIR/.booth/home"
fi
if [ -n "$CB_HOME_DIR" ]; then
  log "Copying project home files from $CB_HOME_DIR to $HOME_DIR..."
  cp -rn "$CB_HOME_DIR/." "$HOME_DIR/" 2>/dev/null || true
  chown -R "$HOST_UID:$HOST_GID" "$HOME_DIR" 2>/dev/null || true
fi


log "12) Copying seed files from /tmp/cb-home-seed/ to /home/coder ..."
# This allows mounting host files read-only to /tmp/cb-home-seed/ (e.g., credentials)
# and getting a writable copy in the user's home directory.
# Files are copied without overwriting existing ones (cp -rn).
# NOTE: cb-home-seed runs AFTER .booth/home, so host files take precedence over project files.
CB_HOME_SEED="/tmp/cb-home-seed"
if [ -d "$CB_HOME_SEED" ]; then
  log "Copying seed files from $CB_HOME_SEED to $HOME_DIR..."
  # Copy all contents, preserving structure, without overwriting existing files
  cp -rn "$CB_HOME_SEED/." "$HOME_DIR/" 2>/dev/null || true
  # Fix ownership of copied files
  chown -R "$HOST_UID:$HOST_GID" "$HOME_DIR" 2>/dev/null || true
fi

log "13) Running one-time CodingBooth startup hooks in /usr/share/startup.d..."
RUN_ONCE_FLAG="/var/run/cb-startup.once"
if [ -d "/usr/share/startup.d" ] && [ ! -f "$RUN_ONCE_FLAG" ]; then
  runuser -u "$USER_NAME" -- bash -lc '
    # Run the startup.
    set -euo pipefail
    shopt -s nullglob
    echo "Scan for CodingBooth startup hooks in /usr/share/startup.d..."           >> /tmp/startups.txt
    for f in /usr/share/startup.d/*-cb-*.sh; do
      echo "Found startup script: $f ---"                                          >> /tmp/startups.txt
    done
    echo "Scan completed: $(ls /usr/share/startup.d/*-cb-*.sh | wc -l) found."     >> /tmp/startups.txt
    echo ""                                                                        >> /tmp/startups.txt
    echo "Running startup scripts..."                                              >> /tmp/startups.txt
    for f in /usr/share/startup.d/*-cb-*.sh; do
      echo "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" >> /tmp/startups.txt
      echo "Running startup script: $f ---"                                        >> /tmp/startups.txt
      [ -r "$f" ] && "$f"                                                          >> /tmp/startups.txt
      echo "---------------------------------------------------------------------" >> /tmp/startups.txt
    done
  '
  touch "$RUN_ONCE_FLAG"
fi

log "14) Running user custom startup script (from --startup or .booth/startup.sh)"
# Use CB_STARTUP if set, otherwise check for .booth/startup.sh in code path
CB_STARTUP_SCRIPT="${CB_STARTUP:-}"
if [ -z "$CB_STARTUP_SCRIPT" ] && [ -f "$CODE_DIR/.booth/startup.sh" ]; then
  CB_STARTUP_SCRIPT="$CODE_DIR/.booth/startup.sh"
fi
if [ -n "$CB_STARTUP_SCRIPT" ] && [ -f "$CB_STARTUP_SCRIPT" ] && [ -r "$CB_STARTUP_SCRIPT" ]; then
  log "Running user startup script: $CB_STARTUP_SCRIPT"
  runuser -u "$USER_NAME" -- bash -lc "
    set -euo pipefail
    source '$CB_STARTUP_SCRIPT'
  "
fi


log "15) Executing the requested command as coder (default to login shell if none provided)"
if [ "$#" -eq 0 ]; then
  log "No command provided; starting login shell for $USER_NAME..."
  exec runuser -u "$USER_NAME" --login
else
  log "Executing as $USER_NAME: $*"
  exec runuser -u "$USER_NAME" -- "$@"
fi
