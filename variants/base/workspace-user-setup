#!/usr/bin/env bash
set -euo pipefail

# -----------------------------------------------------------------------------
# workspace-user-setup
#
# Purpose:
#   Container entry script that aligns the in-container "coder" user/group with
#   the host's UID/GID, ensures passwordless sudo, prepares $HOME and workspace,
#   and finally execs the given command as "coder".
#
#   This allows files created in the container to be owned by the host user
#   when a bind mount is used (e.g., -v $PWD:/home/coder/workspace).
#
# How it works (idempotent):
#   1) Ensure group "coder" exists and has GID=HOST_GID (moving any group that
#      already holds HOST_GID out of the way, preserving names).
#   2) Ensure user "coder" exists and has UID=HOST_UID, primary group "coder",
#      and login shell USER_SHELL (moving any user that already holds HOST_UID).
#   3) Add passwordless sudo for "coder".
#   4) Create $HOME and $WORKSPACE.
#   5) cd into $WORKSPACE_PATH and exec the given command as "coder".
#
# Environment variables:
#   HOST_UID           Host user id (default: 1000)
#   HOST_GID           Host group id (default: 1000)
#   USER_SHELL         Shell for "coder" (default: /bin/bash)
#
#   USER_NAME          Target username inside container (default: coder)  [const below]
#   HOME_DIR           Home dir for USER_NAME (default: /home/coder)      [const below]
#   WORDKSPACE         Folder name inside container (default: workspace)  [const below]
#   WORKSPACE_DIR      Workspace dir (default: /home/coder/workspace)     [const below]
#
# Usage:
#   As container entrypoint (Dockerfile):
#     COPY workspace-entry /usr/local/bin/
#     ENTRYPOINT ["/usr/local/bin/workspace-entry"]
#     CMD ["bash"]   # or your default command
#
#   With docker run (example):
#     docker run --rm -it \
#       -e HOST_UID=$(id -u) -e HOST_GID=$(id -g) \
#       -v "$PWD":/home/coder/workspace \
#       your-image
#
# Notes:
#   • This script prefers to minimally mutate the system: it only moves aside
#     conflicting UID/GID holders when necessary.
#   • Designed to be re-run safely (idempotent).
#   • No-op if host UID/GID matches current "coder" UID/GID and ownership is OK.
# -----------------------------------------------------------------------------

# Verbose logging (default: false)
WS_VERBOSE="${WS_VERBOSE:-false}"
log() {
  if [ "$WS_VERBOSE" = "true" ]; then
    printf '[ws-setup] %s\n' "$*"
  fi
}

log "Start workspace-user-steup $@ ..."

#== Constants ==
USER_NAME="coder"
HOME_DIR="/home/${USER_NAME}"

WORKSPACE_NAME=${WORKSPACE_NAME:-workspace}
WORKSPACE_DIR="/home/${USER_NAME}/${WORKSPACE_NAME}"

# Allow environment to override config
USER_SHELL="${USER_SHELL:-/bin/bash}"
HOST_UID="${HOST_UID:-1000}"
HOST_GID="${HOST_GID:-1000}"


log "USER_NAME=$USER_NAME HOME_DIR=$HOME_DIR WORKSPACE_DIR=$WORKSPACE_DIR"
log "HOST_UID=$HOST_UID HOST_GID=$HOST_GID"

# Find a free numeric uid/gid starting from 2000 to relocate conflicts safely
find_free_uid() { local uid=2000; while getent passwd "$uid" >/dev/null 2>&1; do uid=$((uid+1)); done; echo "$uid"; }
find_free_gid() { local gid=2000; while getent group  "$gid" >/dev/null 2>&1; do gid=$((gid+1)); done; echo "$gid"; }

# Wrappers to hide "no changes" noise while preserving behavior/exit codes
UserMod() {
  usermod "$@" 2> >(grep -v -F "usermod: no changes" >&2)
}

GroupMod() {
  groupmod "$@" 2> >(grep -v -F "groupmod: no changes" >&2)
}

# --- GROUP: ensure HOST_GID is owned by group 'coder' ---
log "Ensuring group '$USER_NAME' exists and matches HOST_GID..."

# 1) Ensure 'coder' group exists (with any GID for now). Prefer HOST_GID if free.
if ! getent group "$USER_NAME" >/dev/null 2>&1; then
  if getent group "$HOST_GID"  >/dev/null 2>&1; then
    groupadd "$USER_NAME"               # temp gid
  else
    groupadd -g "$HOST_GID" "$USER_NAME"
  fi
fi

# 2) If some other group owns HOST_GID, move it to a free gid (keep its name)
owner_of_host_gid="$(getent group "$HOST_GID" | cut -d: -f1 || true)"
if [ -n "$owner_of_host_gid" ] && [ "$owner_of_host_gid" != "$USER_NAME" ]; then
  tmp_gid="$(find_free_gid)"
  GroupMod -g "$tmp_gid" "$owner_of_host_gid"
fi

# 3) Set 'coder' group's gid to HOST_GID (if not already)
current_gid="$(getent group "$USER_NAME" | cut -d: -f3)"
if [ "$current_gid" != "$HOST_GID" ]; then
  GroupMod -g "$HOST_GID" "$USER_NAME"
fi

# --- USER: align UID and ensure primary group is 'coder' by name ---
log "Ensuring user '$USER_NAME' exists and matches HOST_UID..."

existing_uid_user="$(getent passwd "$HOST_UID" | cut -d: -f1 || true)"
if id -u "$USER_NAME" >/dev/null 2>&1; then
  current_uid="$(id -u "$USER_NAME")"
  # minimal additions: detect current primary group name and shell
  current_gid_name="$(id -gn "$USER_NAME")"
  current_shell="$(getent passwd "$USER_NAME" | cut -d: -f7 || true)"

  if [ "$current_uid" != "$HOST_UID" ]; then
    # If another user has HOST_UID, move them out of the way
    if [ -n "$existing_uid_user" ] && [ "$existing_uid_user" != "$USER_NAME" ]; then
      temp_uid="$(find_free_uid)"; UserMod -u "$temp_uid" "$existing_uid_user"
    fi
    UserMod -u "$HOST_UID" -g "$USER_NAME" -s "$USER_SHELL" "$USER_NAME"
  else
    # Only call usermod if group or shell actually differ (avoid "no changes" noise)
    if [ "$current_gid_name" != "$USER_NAME" ] || [ "$current_shell" != "$USER_SHELL" ]; then
      UserMod -g "$USER_NAME" -s "$USER_SHELL" "$USER_NAME"
    fi
  fi
else
  # 'coder' doesn't exist yet; if HOST_UID is already taken, move that user aside
  if [ -n "$existing_uid_user" ] && [ "$existing_uid_user" != "$USER_NAME" ]; then
    temp_uid="$(find_free_uid)"; UserMod -u "$temp_uid" "$existing_uid_user"
  fi
  # Create coder. Reuse existing HOME_DIR if present; otherwise create it (-m).
  if [ -d "$HOME_DIR" ]; then
    useradd    -u "$HOST_UID" -g "$USER_NAME" -s "$USER_SHELL" "$USER_NAME"
  else
    useradd -m -u "$HOST_UID" -g "$USER_NAME" -s "$USER_SHELL" "$USER_NAME"
  fi
fi

# Allow passwordless sudo for coder (restricted to this file)
log "Configuring passwordless sudo for '$USER_NAME'..."
echo "${USER_NAME} ALL=(ALL) NOPASSWD:ALL" >/etc/sudoers.d/${USER_NAME}
chmod 0440 /etc/sudoers.d/${USER_NAME}

# OK, I don't know where are these from but it need to be belong to the user
find "${HOME_DIR}"         \
  -path "${WORKSPACE_DIR}" \
  -prune                   \
  -o                       \
  -exec chown "${HOST_UID}:${HOST_GID}" {} + >/dev/null 2>&1 || true

# Set up environment for coder and switch to workspace
export HOME="$HOME_DIR"
export PATH="$HOME/.local/bin:$PATH"
cd "$WORKSPACE_DIR" 2>/dev/null || true

# Populate skeleton dotfiles if missing (so non-login shells get env/aliases)
log "Ensuring default dotfiles exist in $HOME_DIR..."


if [ ! -f "$HOME_DIR/.bashrc" ]; then
  if [ -f /etc/skel/.bashrc ]; then
    cp /etc/skel/.bashrc "$HOME_DIR/.bashrc"
  fi
  touch "$HOME_DIR/.bashrc"
  echo 'export PS1="\[\e[1;32m\]${WS_CONTAINER_NAME}\[\e[0m\]:\[\e[1;34m\]\w\[\e[0m\]\$ "' >> "$HOME_DIR/.bashrc"
  # the below will include username but we know that it always "coder" so let use the above first to see if that is ok.
  # echo 'export PS1="\[\e[1;32m\]\u\[\e[0m\]@\[\e[1;33m\]${WS_CONTAINER_NAME}\[\e[0m\]:\[\e[1;34m\]\w\[\e[0m\]\$ "' >> "$HOME_DIR/.bashrc"
fi
if [ ! -f "$HOME_DIR/.zshrc" ]; then
  [ -f /etc/skel/.zshrc ] && cp /etc/skel/.zshrc "$HOME_DIR/.zshrc"
  {
    printf '\n# ---- custom prompt (added at build) ----\n'
    printf 'setopt PROMPT_SUBST\n'  # allow ${...} in PROMPT
    printf 'PROMPT="%%B%%F{green}${WS_CONTAINER_NAME}%%b%%f:%%B%%F{blue}%%~%%b%%f❯ "\n'
    # the below will include username but we know that it always "coder" so let use the above first to see if that is ok.
    # printf 'PROMPT="%%B%%F{green}%%n%%b%%f@%%B%%F{yellow}${WS_CONTAINER_NAME}%%b%%f:%%B%%F{blue}%%~%%b%%f❯ "\n'
    printf '# ---- end custom prompt ----\n'
  } >> "$HOME_DIR/.zshrc"
  chown "$USER_NAME:$USER_NAME" "$HOME_DIR/.zshrc"
fi

if [ ! -f "$HOME_DIR/.profile" ]; then
  if [ -f /etc/skel/.profile ]; then
    cp /etc/skel/.profile "$HOME_DIR/.profile"
  fi
fi

if [ -f "$HOME_DIR/.bashrc" ]; then
  cat >>"$HOME_DIR/.bashrc" <<'RC'

# ---- workspace startup hooks ----
for f in /etc/profile.d/*-ws-*.sh; do
  [ -r "$f" ] && source "$f"
done
RC
fi

if [ -f "$HOME_DIR/.zshrc" ]; then
  cat >>"$HOME_DIR/.zshrc" <<'RC'

# ---- workspace startup hooks ----
for f in /etc/profile.d/*-ws-*.sh; do
  [ -r "$f" ] && source "$f"
done
RC
fi

if [ ! -f "$HOME_DIR/.profile" ]; then
  cat >>"$HOME_DIR/.profile" <<'RC'
# Minimal profile for login shells
[ -f /etc/profile ] && . /etc/profile
RC
fi

chown "$HOST_UID:$HOST_GID" "$HOME_DIR/.bashrc" "$HOME_DIR/.profile" "$HOME_DIR/.zshrc" 2>/dev/null || true

# --- Copy project's ws--home folder (team-shared defaults) ---
# This allows teams to share common dotfiles, configs, or tool settings via version control.
# Files are copied without overwriting existing ones (cp -rn).
WS_HOME_DIR="$WORKSPACE_DIR/ws--home"
if [ -d "$WS_HOME_DIR" ]; then
  log "Copying project home files from $WS_HOME_DIR to $HOME_DIR..."
  cp -rn "$WS_HOME_DIR/." "$HOME_DIR/" 2>/dev/null || true
  chown -R "$HOST_UID:$HOST_GID" "$HOME_DIR" 2>/dev/null || true
fi

# --- Copy-on-write staging: copy from /tmp/ws-home-seed to $HOME ---
# This allows mounting host files read-only to /tmp/ws-home-seed/ (e.g., credentials)
# and getting a writable copy in the user's home directory.
# Files are copied without overwriting existing ones (cp -rn).
# NOTE: ws-home-seed runs AFTER ws--home, so host files take precedence over project files.
WS_HOME_SEED="/tmp/ws-home-seed"
if [ -d "$WS_HOME_SEED" ]; then
  log "Copying seed files from $WS_HOME_SEED to $HOME_DIR..."
  # Copy all contents, preserving structure, without overwriting existing files
  cp -rn "$WS_HOME_SEED/." "$HOME_DIR/" 2>/dev/null || true
  # Fix ownership of copied files
  chown -R "$HOST_UID:$HOST_GID" "$HOME_DIR" 2>/dev/null || true
fi

# --- One-time workspace startup hooks (run as $USER_NAME) ---
RUN_ONCE_FLAG="/var/run/ws-startup.once"
if [ -d "/usr/share/startup.d" ] && [ ! -f "$RUN_ONCE_FLAG" ]; then
  log "Running one-time workspace startup hooks in /usr/share/startup.d..."
  runuser -u "$USER_NAME" -- bash -lc '
    # Run the startup.
    set -euo pipefail
    shopt -s nullglob
    for f in /usr/share/startup.d/*-ws-*.sh; do
      echo "$f" >> /tmp/startups.txt
      [ -r "$f" ] && "$f"
    done
  '
  touch "$RUN_ONCE_FLAG"
fi

# Exec the requested command as coder (default to login shell if none provided)
if [ "$#" -eq 0 ]; then
  log "No command provided; starting login shell for $USER_NAME..."
  exec runuser -u "$USER_NAME" --login
else
  log "Executing as $USER_NAME: $*"
  exec runuser -u "$USER_NAME" -- "$@"
fi
