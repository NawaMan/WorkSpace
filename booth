#!/bin/bash
# Copyright 2025-2026 : Nawa Manusitthipol
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.


# CodingBooth Wrapper (booth)
# Downloads, verifies, and runs the platform-specific CodingBooth binary.
# Install: curl -fsSL https://github.com/NawaMan/WorkSpace/releases/download/latest/booth | bash

set -euo pipefail
trap 'status=$?; echo "❌ Error on line $LINENO (exit $status)" >&2; exit "$status"' ERR

# --- PIPE INSTALL DETECTION ---
# Detect if running via pipe (curl ... | bash)
# When piped, $0 is the shell name, not a script path
if [[ "$0" == "bash" || "$0" == "-bash" || "$0" == "/bin/bash" || \
      "$0" == "sh"   || "$0" == "-sh"   || "$0" == "/bin/sh"   || \
      "$0" == "zsh"  || "$0" == "-zsh"  || "$0" == "/bin/zsh" ]]; then
    echo "Installing CodingBooth wrapper..."
    curl -fsSL -o booth https://github.com/NawaMan/WorkSpace/releases/download/latest/booth
    chmod +x booth
    echo ""
    echo ""
    echo ""
    ./booth install
    echo ""
    echo "✅ CodingBooth has been installed."
    echo ""
    echo ""
    echo ""
    echo "Run './booth help' to see available commands."
    echo ""
    ./booth help
    exit 0
fi

VERSION=0.6.0
VERBOSE="${VERBOSE:-true}"

# Decide what the "command" is:
if [[ $# -eq 0 ]]; then COMMAND="run" ; else COMMAND="$1" ; fi

function Main() {
    ### --- COMMAND DISPATCH --- ###
    case "${COMMAND}" in
        uninstall)      UninstallBooth               ; exit 0 ; ;;
        install|update) DownloadBooth "${2:-latest}" ; exit 0 ; ;;
        run)            [[ "${1-}" == "run" ]] && shift  ;          ;;
        *)                                                          ;;
    esac

    ### --- RUN MODE --- ###
    tools_dir=".booth/tools"
    sha_file="$tools_dir/coding-booth.sha256"
    lock_file="$tools_dir/coding-booth.lock"

    # Detect current platform and get the correct binary
    local platform binary_name dest
    if ! platform=$(detect_platform); then
        echo "Error: Failed to detect platform" >&2
        exit 1
    fi
    binary_name=$(get_binary_name "$platform")
    dest="$tools_dir/$binary_name"

    # If lock file exists but binary is missing, auto-download from lock version
    if [[ -f "$lock_file" && ( ! -f "$dest" || ! -f "$sha_file" ) ]]; then
        local lock_version
        lock_version=$(grep '^version=' "$lock_file" 2>/dev/null | cut -d= -f2-)
        if [[ -n "$lock_version" ]]; then
            echo "Binary missing, downloading version $lock_version from lock file..."
            DownloadBooth "$lock_version"
        else
            echo "CodingBooth is not installed correctly for platform: $platform"
            echo "Please run: $0 install"
            exit 1
        fi
    fi

    if [[ ! -f "$dest" || ! -f "$sha_file" || ! -f "$lock_file" ]]; then
        echo "CodingBooth is not installed correctly for platform: $platform"
        echo "Please run: $0 install"
        exit 1
    fi

    # Ensure booth binary is newer than checksum
    if [[ "$dest" -ot "$sha_file" ]]; then
        echo "booth binary appears older than its checksum file."
        echo "Run: $0 update  to restore the official release."
        exit 1
    fi

    # Verify SHA256 for this platform's binary
    local expected_sha256 actual_sha256
    expected_sha256=$(grep "  $binary_name\$" "$sha_file" 2>/dev/null | awk '{print $1}')
    if [[ -z "$expected_sha256" ]]; then
        echo "No SHA256 entry found for $binary_name"
        echo "Run: $0 update  to restore the official release."
        exit 1
    fi

    actual_sha256=$(hash_sha256 "$dest" | awk '{print $1}')
    if [[ "$expected_sha256" != "$actual_sha256" ]]; then
        echo "Local booth ($binary_name) failed SHA256 verification."
        echo "Run: $0 update  to restore the official release."
        exit 1
    fi

    exec "$dest" "$@"
}

function PrintHelp() {
    cat <<EOF
Usage: ./$(basename "$0") <command> [args...]

Purpose:
  This script is the *CodingBooth Wrapper*.
  - It is stable and does not update itself.
  - It downloads, verifies, and runs the actual CodingBooth script
    (.booth/tools/coding-booth) from the CodingBooth project.
  - This lets booth evolve independently while keeping a reliable entry point.

Wrapper commands:
  install [VERSION]   Download or update .booth/tools/coding-booth
  update  [VERSION]   Download or update .booth/tools/coding-booth
  uninstall           Remove booth and metadata files
  run [ARGS...]       Run booth with ARGS (after integrity checks)
  version             Show this wrapper's version
  help                Show this help message

Notes:
  - coding-booth.lock and coding-booth.sha256 live in .booth/tools
  - Binaries are auto-downloaded when lock file exists but binary is missing
  - Set VERBOSE=true for extra logs during update
EOF
}

function PrintVersion() {
    cat <<'EOF'
  ____          _ _             ____              _   _
 / ___|___   __| (_)_ __   __ _| __ )  ___   ___ | |_| |__
| |   / _ \ / _` | | '_ \ / _` |  _ \ / _ \ / _ \| __| '_ \
| |__| (_) | (_| | | | | | (_| | |_) | (_) | (_) | |_| | | |
 \____\___/ \__,_|_|_| |_|\__, |____/ \___/ \___/ \__|_| |_|
                          |___/
EOF
    echo "CodingBooth Wrapper: $VERSION"

    local tools_dir=".booth/tools"
    local LOCK="$tools_dir/coding-booth.lock"

    # Detect current platform and get the correct binary
    local platform binary_name TOOL
    platform=$(detect_platform 2>/dev/null || echo "unknown")
    binary_name=$(get_binary_name "$platform")
    TOOL="$tools_dir/$binary_name"

    if [[ ! -f "$TOOL" ]]; then
        echo "CodingBooth: uninstalled (no binary for $platform)"
        exit 0
    fi

    [[ ! -x "$TOOL" ]] && chmod +x "$TOOL" 2>/dev/null || true

    TOOL_VERSION=$("$TOOL" version 2>/dev/null || echo "unknown")

    echo ""
    echo "$TOOL_VERSION"
    echo "Platform: $platform"
}

# Portable SHA256 helper
function hash_sha256() {
    if   command -v sha256sum >/dev/null 2>&1; then sha256sum        "$@"
    elif command -v shasum    >/dev/null 2>&1; then shasum    -a 256 "$@"
    else echo "Error: No SHA256 tool found (sha256sum or shasum)." >&2 ; return 1
    fi
}

# Detect platform (OS-ARCH format)
function detect_platform() {
    local os arch
    
    # Detect OS
    case "$(uname -s)" in
        Linux*)     os="linux" ;;
        Darwin*)    os="darwin" ;;
        MINGW*|MSYS*|CYGWIN*) os="windows" ;;
        *)          echo "Error: Unsupported OS: $(uname -s)" >&2; return 1 ;;
    esac
    
    # Detect architecture
    case "$(uname -m)" in
        x86_64|amd64)   arch="amd64" ;;
        aarch64|arm64)  arch="arm64" ;;
        *)              echo "Error: Unsupported architecture: $(uname -m)" >&2; return 1 ;;
    esac
    
    echo "${os}-${arch}"
}

# Get binary name for platform (adds .exe for Windows)
function get_binary_name() {
    local platform="$1"
    if [[ "$platform" == windows-* ]]; then
        echo "coding-booth-${platform}.exe"
    else
        echo "coding-booth-${platform}"
    fi
}

# All supported platforms (5 total)
ALL_PLATFORMS=(
    "linux-amd64"
    "linux-arm64"
    "darwin-amd64"
    "darwin-arm64"
    "windows-amd64"
)

function UninstallBooth() {
    local tools_dir=".booth/tools"
    local sha_file="$tools_dir/coding-booth.sha256"
    local lock_file="$tools_dir/coding-booth.lock"

    # Remove all platform binaries
    for platform in "${ALL_PLATFORMS[@]}"; do
        local binary_name
        binary_name=$(get_binary_name "$platform")
        rm -f "$tools_dir/$binary_name"
    done

    rm -f "$sha_file" "$lock_file"

    rmdir "$tools_dir" 2>/dev/null || true
    rmdir ".ws" 2>/dev/null || true

    echo "CodingBooth has been uninstalled."
}

function DownloadBooth() {
    CB_VERSION=${1:-latest}
    local tools_dir=".booth/tools"
    local sha_file="$tools_dir/coding-booth.sha256"
    local lock_file="$tools_dir/coding-booth.lock"

    REPO_URL="https://github.com/NawaMan/WorkSpace"
    DWLD_URL="${REPO_URL}/releases/download"

    mkdir -p "$tools_dir"

    # Create .gitignore to exclude binaries (they're large and can be re-downloaded)
    cat > ".booth/.gitignore" <<'GITIGNORE'
# Binaries are excluded - they can be re-downloaded from coding-booth.lock version
tools/coding-booth-*
tools/*.sha256
GITIGNORE

    # Clear previous SHA256 file (will rebuild with all binaries)
    > "$sha_file"

    # Download version.txt to get the actual version
    local actual_version=""
    local VERSION_URL="${DWLD_URL}/${CB_VERSION}/version.txt"
    if actual_version=$(curl -fsSL "$VERSION_URL" 2>/dev/null | tr -d ' \t\r\n'); then
        [[ "$VERBOSE" == "true" ]] && echo "  Version: $actual_version"
    else
        actual_version=""
    fi

    local current_platform
    current_platform=$(detect_platform 2>/dev/null || echo "unknown")
    local download_count=0
    local fail_count=0

    echo "Downloading CodingBooth binaries for all platforms..."

    for platform in "${ALL_PLATFORMS[@]}"; do
        local binary_name
        binary_name=$(get_binary_name "$platform")
        local dest="$tools_dir/$binary_name"
        local TOOL_URL="${DWLD_URL}/${CB_VERSION}/${binary_name}"
        local SHA256_URL="${DWLD_URL}/${CB_VERSION}/${binary_name}.sha256"

        if [[ "$VERBOSE" == "true" ]]; then
            echo "  Downloading: $binary_name"
        else
            echo -n "  $platform ... "
        fi

        local tmpfile tmpsha256
        tmpfile=$(mktemp "/tmp/booth.XXXXXX")
        tmpsha256=$(mktemp "/tmp/booth.sha256.XXXXXX")

        # Download binary
        if ! curl -fsSLo "$tmpfile" "$TOOL_URL"; then
            echo "FAILED (download)"
            rm -f "$tmpfile" "$tmpsha256"
            : $((fail_count++))
            continue
        fi

        # Download SHA256
        if ! curl -fsSLo "$tmpsha256" "$SHA256_URL"; then
            echo "FAILED (sha256)"
            rm -f "$tmpfile" "$tmpsha256"
            : $((fail_count++))
            continue
        fi

        # Verify SHA256
        local expected_sha256 actual_sha256
        expected_sha256=$(awk '{print $1}' "$tmpsha256")
        if ! [[ "$expected_sha256" =~ ^[0-9a-fA-F]{64}$ ]]; then
            echo "FAILED (malformed sha256)"
            rm -f "$tmpfile" "$tmpsha256"
            : $((fail_count++))
            continue
        fi

        actual_sha256=$(hash_sha256 "$tmpfile" | awk '{print $1}')
        if [[ "$expected_sha256" != "$actual_sha256" ]]; then
            echo "FAILED (sha256 mismatch)"
            rm -f "$tmpfile" "$tmpsha256"
            : $((fail_count++))
            continue
        fi

        # Install verified binary
        chmod +x "$tmpfile"
        mv -f "$tmpfile" "$dest"
        chmod +x "$dest"

        # Append to combined SHA256 file
        printf '%s  %s\n' "$actual_sha256" "$binary_name" >> "$sha_file"

        rm -f "$tmpsha256"
        : $((download_count++))

        if [[ "$VERBOSE" != "true" ]]; then
            echo "✅ OK"
        fi
    done

    if [[ $fail_count -gt 0 ]]; then
        echo "Warning: $fail_count platform(s) failed to download" >&2
    fi

    if [[ $download_count -eq 0 ]]; then
        echo "Error: No binaries were downloaded successfully" >&2
        return 1
    fi

    # Write metadata
    {
        echo "version=${actual_version}"
        echo "downloaded_at=$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
    } > "$lock_file"

    # Touch all binaries to be newer than checksum
    for platform in "${ALL_PLATFORMS[@]}"; do
        local binary_name
        binary_name=$(get_binary_name "$platform")
        local dest="$tools_dir/$binary_name"
        [[ -f "$dest" ]] && touch "$dest"
    done

    echo "CodingBooth installed: downloaded, verified, and installed."
    if [[ "$VERBOSE" == "true" ]]; then
        echo "Lock file: $lock_file"
    fi
}

# Early handling of version/help so they don't require curl
case "${COMMAND}" in
    version) PrintVersion ; exit 0 ; ;;
    help)    PrintHelp    ; exit 0 ; ;;
esac

# Need curl for install/run/update/uninstall
if ! command -v curl >/dev/null 2>&1; then
    echo "Error: curl is required but was not found." >&2
    exit 1
fi

Main "$@"
